[{"title":"你好，世界！","url":"/2022/06/10/hello-world/","content":"你好，世界！\n"},{"title":"哈夫曼树的C++实现","url":"/2021/03/07/huffman-tree-cpp/","content":"此博客来源于本人洛谷博客。\n简介\n给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树（Huffman Tree）。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。\n\n以上内容来自百度百科。\n哈夫曼树有许多应用，包括哈夫曼编码。\n关于树的带权路径长度（WPL），下面附上定义。\n\n树的所有叶结点的带权路径长度之和，称为树的带权路径长度，表示为WPL。\n\n以上内容来自百度百科。\n关于带权路径长度，下面也附上定义。\n\n一个叶节点的带权路径长度为它的权乘它到根节点经过路径的总和。简单来说，它到根节点有多远与它权的乘积。\n\n以上内容是我自己写的。\n代码实现#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;long long n, cur;struct tree&#123;    long long weight, num, parent, lch, rch;    bool flag = 0, used = 0;&#125;;bool cmp1( tree a, tree b )&#123;    if( ( a.flag == 1 &amp;&amp; b.flag == 1 ) || ( a.flag == 0 &amp;&amp; b.flag == 0 ) )    &#123;        return a.weight &lt; b.weight;    &#125;    else if( a.flag == 1 &amp;&amp; b.flag == 0 )    &#123;        return 1;    &#125;    else if( a.flag == 0 &amp;&amp; b.flag == 1 )    &#123;        return 0;    &#125;    return a.weight &lt; b.weight;&#125;bool cmp2( tree a, tree b )&#123;    return a.num &lt; b.num;&#125;int main()&#123;    tree t[10005];    cin &gt;&gt; n;    cur = n;    for( long long i = 1; i &lt;= 2 * n - 1; i++ )    &#123;        t[i].num = i;    &#125;    for( long long i = 1; i &lt;= n; i++ )    &#123;        cin &gt;&gt; t[i].weight;        t[i].flag = 1;        t[i].used = 1;        t[i].lch = 0;        t[i].rch = 0;    &#125;    sort( t + 1, t + cur + 1, cmp1 );    while( !t[2 * n - 1].used )    &#123;        t[cur + 1].weight = t[1].weight + t[2].weight;        t[cur + 1].lch = t[1].num;        t[cur + 1].rch = t[2].num;        t[1].parent = t[cur + 1].num;        t[2].parent = t[cur + 1].num;        t[1].flag = 0;        t[2].flag = 0;        t[cur + 1].flag = 1;        t[cur + 1].used = 1;        cur += 1;        sort( t + 1, t + cur + 1, cmp1 );    &#125;    sort( t + 1, t + 2 * n, cmp2 );    for( long long i = 1; i &lt;= 2 * n - 1; i++ )    &#123;        cout &lt;&lt; t[i].num &lt;&lt; &quot; &quot; &lt;&lt; t[i].weight &lt;&lt; &quot; &quot; &lt;&lt; t[i].parent &lt;&lt; &quot; &quot; &lt;&lt; t[i].lch &lt;&lt; &quot; &quot; &lt;&lt; t[i].rch &lt;&lt; endl;    &#125;    return 0;&#125;","categories":["C++"],"tags":["算法","数据结构","哈夫曼树"]}]